// Generated by CoffeeScript 1.4.0

var codearea = function(area) {
  var __slice = [].slice;
  var even;
  even = function(n) {
    return n % 2 === 0;
  };
  var at_line_end, at_line_sta, call_shortcut, get_col, get_row, key_backspace, key_bracket, key_bracket_close, key_ctrl_enter, key_ctrl_k, key_ctrl_l, key_ctrl_shift_d, key_ctrl_shift_down, key_ctrl_shift_enter, key_ctrl_shift_k, key_ctrl_shift_up, key_ctrl_u, key_enter, key_esc, key_home, key_quote, key_shift_tab, key_tab, o, set_position, wrap_text, write_text;
  o = function() {
    // var v;
    // v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    // return console.log(v);
  };
  wrap_text = function() {
    var ac, all, ar, contx, end, obj, sta;
    sta = area.selectionStart;
    end = area.selectionEnd;
    contx = area.value;
    all = contx.split('\n');
    ar = get_row(contx, sta);
    ac = get_col(contx, sta);
    return obj = {
      row: ar,
      col: ac,
      all: all,
      ar: ar,
      ac: ac,
      as: at_line_sta(contx, sta),
      ae: at_line_end(contx, sta),
      br: get_row(contx, end),
      bc: get_col(contx, end),
      bs: at_line_sta(contx, end),
      be: at_line_end(contx, end),
      same: sta === end
    };
  };
  write_text = function(obj) {
    var ac, ar, arr, bc, br, end_line;
    arr = obj.all.length > 0 ? obj.all : [''];
    end_line = arr.length - 1;
    ar = obj.ar != null ? obj.ar : end_line;
    ac = obj.ac != null ? obj.ac : arr[ar].length;
    br = obj.br != null ? obj.br : ar;
    if (obj.bc != null) {
      bc = obj.bc;
    } else {
      if (obj.br != null) {
        bc = arr[br].length;
      } else {
        bc = ac;
      }
    }
    area.value = arr.join('\n');
    area.selectionStart = set_position(arr, ar, ac);
    area.selectionEnd = set_position(arr, br, bc);
    return false;
  };
  set_position = function(arr, row, col) {
    var all_before_curse, inline_before_curse, position, text_before_curse;
    all_before_curse = arr.slice(0, row);
    inline_before_curse = arr[row] != null ? arr[row].slice(0, col) : '';
    all_before_curse.push(inline_before_curse);
    text_before_curse = all_before_curse.join('\n');
    return position = text_before_curse.length;
  };
  get_row = function(str, point) {
    var count, i, _i, _len;
    count = 0;
    str = str.slice(0, point);
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      i = str[_i];
      if (i === '\n') {
        count += 1;
      }
    }
    return count;
  };
  get_col = function(str, point) {
    var last, n, sub_str;
    str = str.slice(0, point);
    last = str.lastIndexOf('\n');
    last += 1;
    sub_str = str.slice(last);
    return n = sub_str.length;
  };
  at_line_sta = function(text, point) {
    var p;
    p = point - 1;
    if (text[p] === '\n') {
      return true;
    }
    if (text[p] == null) {
      return true;
    }
    return false;
  };
  at_line_end = function(text, point) {
    var p;
    p = point;
    if (text[p] === '\n') {
      return true;
    }
    if (text[p] == null) {
      return true;
    }
    return false;
  };
  key_tab = function() {
    var ac, add_n, all, ar, bc, br, caret, index, space_n, spaces, _i;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
    if (caret.same) {
      if (caret.as && ar > 0 && all[ar - 1].match(/^\s+/)) {
        spaces = (all[ar - 1].match(/^\s+/))[0];
        all[ar] = spaces + all[ar];
        ac = spaces.length;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      } else {
        spaces = (all[ar].match(/^\s*/))[0];
        space_n = spaces.length;
        add_n = 2 - space_n % 2;
        if (add_n === 1) {
          all[ar] = '\ ' + all[ar];
        } else {
          all[ar] = '\ \ ' + all[ar];
        }
        ac += add_n;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    } else {
      ar = caret.ar;
      br = caret.br;
      for (index = _i = ar; ar <= br ? _i <= br : _i >= br; index = ar <= br ? ++_i : --_i) {
        all[index] = '\ \ ' + all[index];
      }
      ac += 2;
      bc += 2;
      return write_text({
        all: all,
        ar: ar,
        ac: ac,
        br: br,
        bc: bc
      });
    }
  };
  key_shift_tab = function() {
    var ac, all, ar, bc, br, caret, index, min_spaces, obj, reduce_n, space_n, space_ns, spaces, _i;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
    if (caret.same) {
      ar = caret.ar;
      spaces = (all[ar].match(/^\s*/))[0];
      space_n = spaces.length;
      reduce_n = 2 - spaces % 2;
      if (space_n >= reduce_n) {
        all[ar] = all[ar].slice(reduce_n);
        obj = {
          all: all,
          ar: ar
        };
        ac = ac - reduce_n > 0 ? ac - reduce_n : 0;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    } else {
      space_ns = all.slice(ar, +br + 1 || 9e9).map(function(line) {
        spaces = (line.match(/^\s*/))[0];
        return spaces.length;
      });
      min_spaces = space_ns.reduce(function(a, b) {
        if (a < b) {
          return a;
        } else {
          return b;
        }
      });
      if (min_spaces > 0) {
        reduce_n = 2 - min_spaces % 2;
        for (index = _i = ar; ar <= br ? _i <= br : _i >= br; index = ar <= br ? ++_i : --_i) {
          all[index] = all[index].slice(reduce_n);
        }
        ac -= reduce_n;
        bc -= reduce_n;
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    }
  };
  key_ctrl_l = function() {
    var ac, all, ar, bc, br, caret;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, br = caret.br, bc = caret.bc;
    ac = 0;
    if (all[ar - 1] != null) {
      ar -= 1;
      ac = void 0;
    }
    return write_text({
      all: all,
      ar: ar,
      ac: ac,
      br: br,
      bc: bc
    });
  };
  key_ctrl_k = function() {
    var ac, all, ar, caret;
    caret = wrap_text();
    if (caret.same) {
      all = caret.all, ar = caret.ar, ac = caret.ac;
      all[ar] = all[ar].slice(0, ac);
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    }
  };
  key_ctrl_u = function() {
    var ac, all, ar, caret;
    caret = wrap_text();
    if (caret.same) {
      all = caret.all, ar = caret.ar, ac = caret.ac;
      all[ar] = all[ar].slice(ac);
      ac = 0;
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    }
  };
  key_esc = function() {
    return area.blur();
  };
  key_ctrl_shift_k = function() {
    var ac, all, ar, br, caret;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, br = caret.br;
    if (caret.same) {
      all = all.slice(0, ar).concat(all.slice(ar + 1));
      ac = 0;
      if (ar !== 0) {
        ar -= 1;
        ac = void 0;
      }
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    } else {
      all = all.slice(0, ar).concat(all.slice(br + 1));
      ar = ar > 0 ? ar - 1 : 0;
      return write_text({
        all: all,
        ar: ar
      });
    }
  };
  key_ctrl_shift_d = function() {
    var ac, all, ar, bc, br, caret, duplicate;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
    if (caret.same) {
      all = all.slice(0, +ar + 1 || 9e9).concat(all.slice(ar));
      ar += 1;
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    } else {
      all = all.slice(0, +br + 1 || 9e9).concat(all.slice(ar));
      duplicate = br - ar + 1;
      ar += duplicate;
      br += duplicate;
      return write_text({
        all: all,
        ar: ar,
        ac: ac,
        br: br,
        bc: bc
      });
    }
  };
  key_enter = function() {
    var ac, all, ar, caret, line, spaces;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac;
    if (caret.same) {
      all = all.slice(0, +ar + 1 || 9e9).concat(all.slice(ar));
      line = all[ar];
      all[ar] = all[ar].slice(0, ac);
      spaces = (all[ar].match(/^\s*/))[0];
      all[ar + 1] = spaces + line.slice(ac);
      o(all);
      ac = spaces.length;
      ar += 1;
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    }
  };
  key_backspace = function() {
    var ac, all, ar, caret, n, pair;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac;
    if (caret.same) {
      if (all[ar].slice(0, ac).match(/^\s+$/)) {
        n = all[ar].slice(0, ac).length;
        if (even(n)) {
          all[ar] = all[ar].slice(0, n - 2) + all[ar].slice(n);
        } else {
          all[ar] = all[ar].slice(0, n - 1) + all[ar].slice(n);
        }
        ac = n - 2;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      } else if ((all[ar - 1] != null) && caret.as) {
        if (all[ar - 1].match(/^\s+$/)) {
          all = all.slice(0, ar - 1).concat(all.slice(ar));
          ar = ar - 1;
          ac = 0;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      } else if (all[ar].length > 1 && (!caret.ae)) {
        pair = all[ar].slice(ac - 1, +ac + 1 || 9e9);
        if (pair === '{}' || pair === '()' || pair === '[]' || pair === '""' || pair === "''" || pair === '``') {
          all[ar] = all[ar].slice(0, ac - 1) + all[ar].slice(ac + 1);
          ac -= 1;
          return write_text({
            all: all,
            ar: ar,
            ac: ac
          });
        }
      }
    }
  };
  key_ctrl_enter = function() {
    var all, ar, caret, new_line;
    caret = wrap_text();
    all = caret.all, ar = caret.ar;
    if (caret.same) {
      new_line = (all[ar].match(/^\s*/))[0];
      all = all.slice(0, +ar + 1 || 9e9).concat([new_line]).concat(all.slice(ar + 1));
      ar += 1;
      return write_text({
        all: all,
        ar: ar
      });
    }
  };
  key_ctrl_shift_enter = function() {
    var all, ar, caret, new_line;
    caret = wrap_text();
    all = caret.all, ar = caret.ar;
    if (caret.same) {
      new_line = (all[ar].match(/^\s*/))[0];
      all = all.slice(0, ar).concat([new_line]).concat(all.slice(ar));
      return write_text({
        all: all,
        ar: ar
      });
    }
  };
  key_ctrl_shift_up = function() {
    var ac, all, ar, bc, br, caret, index, line, t_line, _i, _len, _ref, _ref1;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
    if (caret.same) {
      if (ar > 0) {
        _ref = [all[ar - 1], all[ar]], all[ar] = _ref[0], all[ar - 1] = _ref[1];
        ar -= 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    } else {
      if (ar > 0) {
        t_line = all[ar - 1];
        _ref1 = all.slice(ar, +br + 1 || 9e9);
        for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
          line = _ref1[index];
          all[ar + index - 1] = line;
        }
        all[br] = t_line;
        ar -= 1;
        br -= 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    }
  };
  key_ctrl_shift_down = function() {
    var ac, all, ar, bc, br, caret, index, line, t_line, _i, _len, _ref, _ref1;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac, bc = caret.bc, br = caret.br;
    if (caret.same) {
      if (ar < all.length - 1) {
        _ref = [all[ar + 1], all[ar]], all[ar] = _ref[0], all[ar + 1] = _ref[1];
        ar += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    } else {
      if (br < all.length - 1) {
        t_line = all[br + 1];
        _ref1 = all.slice(ar, +br + 1 || 9e9);
        for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
          line = _ref1[index];
          all[ar + index + 1] = line;
        }
        all[ar] = t_line;
        ar += 1;
        br += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac,
          br: br,
          bc: bc
        });
      }
    }
  };
  key_bracket = function(bracket) {
    var ac, all, ar, bc, br, caret;
    caret = wrap_text();
    all = caret.all, ac = caret.ac, ar = caret.ar, br = caret.br, bc = caret.bc;
    all[br] = all[br].slice(0, bc) + bracket[1] + all[br].slice(bc);
    all[ar] = all[ar].slice(0, ac) + bracket[0] + all[ar].slice(ac);
    ac += 1;
    bc += 1;
    return write_text({
      all: all,
      ar: ar,
      ac: ac,
      br: br,
      bc: bc
    });
  };
  key_bracket_close = function(closer) {
    var ac, all, ar, caret, target;
    caret = wrap_text();
    all = caret.all, ar = caret.ar, ac = caret.ac;
    if (caret.same) {
      target = all[ar][ac];
      if ((target != null) && target === closer) {
        ac += 1;
        return write_text({
          all: all,
          ar: ar,
          ac: ac
        });
      }
    }
  };
  key_home = function() {
    var ac, all, ar, caret, spaces;
    caret = wrap_text();
    if (caret.same) {
      all = caret.all, ar = caret.ar, ac = caret.ac;
      spaces = all[ar].match(/^\s+/);
      ac = spaces != null ? spaces[0].length : 0;
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    }
  };
  key_quote = function(sign) {
    var ac, all, ar, bc, br, caret, line;
    caret = wrap_text();
    if (caret.same) {
      all = caret.all, ar = caret.ar, ac = caret.ac;
      line = all[ar];
      if (line[ac] !== sign) {
        all[ar] = line.slice(0, ac) + sign + sign + line.slice(ac);
      }
      ac += 1;
      return write_text({
        all: all,
        ar: ar,
        ac: ac
      });
    } else {
      all = caret.all, ar = caret.ar, ac = caret.ac, br = caret.br, bc = caret.bc;
      line = all[ar];
      all[ar] = line.slice(0, ac) + sign + line.slice(ac);
      ac += 1;
      if (ar === br) {
        bc += 1;
      }
      line = all[br];
      all[br] = line.slice(0, bc) + sign + line.slice(bc);
      return write_text({
        all: all,
        ar: ar,
        ac: ac,
        br: br,
        bc: bc
      });
    }
  };
  call_shortcut = {
    9: key_tab,
    13: key_enter,
    8: key_backspace,
    36: key_home,
    219: function() {
      return key_bracket('[]');
    },
    192: function() {
      return key_quote('`');
    },
    221: function() {
      return key_bracket_close(']');
    },
    222: function() {
      return key_quote("'");
    },
    'shift 9': key_shift_tab,
    'shift 57': function() {
      return key_bracket('()');
    },
    'shift 48': function() {
      return key_bracket_close(')');
    },
    'shift 219': function() {
      return key_bracket('{}');
    },
    'shift 221': function() {
      return key_bracket_close('}');
    },
    'shift 222': function() {
      return key_quote('"');
    },
    'ctrl 76': key_ctrl_l,
    'ctrl 13': key_ctrl_enter,
    'ctrl 75': key_ctrl_k,
    'ctrl 85': key_ctrl_u,
    'ctrl shift 13': key_ctrl_shift_enter,
    'ctrl shift 75': key_ctrl_shift_k,
    'ctrl shift 68': key_ctrl_shift_d,
    'ctrl shift 38': key_ctrl_shift_up,
    'ctrl shift 40': key_ctrl_shift_down
  };
  area.onkeydown = function(e) {
    var mark;
    mark = '';
    if (e.altKey) {
      mark += 'alt ';
    }
    if (e.ctrlKey) {
      mark += 'ctrl ';
    }
    if (e.shiftKey) {
      mark += 'shift ';
    }
    mark += String(e.keyCode);
    o(mark);
    if (call_shortcut[mark] != null) {
      return call_shortcut[mark](area);
    }
  };
};